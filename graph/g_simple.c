/* * Small/graph/g_simple.c *  * (C) 2012-2013 Yafei Zheng <e9999e@163.com> *//* * 该文件包含简单的图形绘制函数。主要针对VESA协议，其中的 * 显存物理地址、行列像素数等在系统初始化时，由BIOS中断获取。 *//* * 关于VESA图形显示模式。 * * 1、资料：read/write的内存设备RAM（DRAM）、read-only的内存设备 * ROM（EPROM），及memory mapped I/O设备都可以映射到物理地址空间上。 * 典型的ROM设备映射到物理地址空间的高端和低端，Video和IGD设备的 * buffer映射到A0000H到BFFFFH的物理地址空间，PCIe等设备映射到物理 * 地址空间的E0000000位置上，I/O APIC 设备映射到FEC00000以上的位置等。 * 经过页式转换形成的物理地址，可以映射到DRAM或外部存储设备Disk上。 * * 2、暂且关掉VESA图形显示模式，要使用之，需在初始化时由BIOS设置好 * 显示模式，并获取对应的显示模式信息。若使用线性地址模式，则在开启了 * 分页内存管理之后，必需设置相应的页表，一般来说，显存对应的物理地址 * 为：0xE0000000。 *//* * [??] NOTE! 如果让图形处理程序运行于用户态，请注意printf()、 * k_printf()、d_printf()一定要使用正确。 *//*#ifndef __DEBUG__#define __DEBUG__#endif*/#include "graph.h"#include "string.h"#include "kernel.h"VbeModeInfoBlock vbe_info = {0};/* * 该函数将RGB颜色值转换为5:6:5的16位颜色值 */unsigned short rgb_to_565color(unsigned char R, unsigned char G, unsigned char B){	unsigned short color = 0;		color |= (R/8) << 11;		/* R*(1<<5)/256 */	color |= (G/4) << 5;		/* G*(1<<6)/256 */	color |= (B/8) << 0;		/* B*(1<<5)/256 */		return color;}/* * 画点。1像素。注意：坐标值从0开始 */BOOL draw_point(unsigned int X, unsigned int Y, unsigned long color){	/* 防止越界 */	X>=vbe_info.xresolution ? X=vbe_info.xresolution-1 : 0;	Y>=vbe_info.yresolution ? Y=vbe_info.yresolution-1 : 0;		/* 计算点对应的显存地址 */	void * point_addr = (void *)(vbe_info.phys_base_ptr 		+ (vbe_info.bits_per_pixel+7)/8 * (Y*vbe_info.xresolution+X));		if(16 == vbe_info.bits_per_pixel)		*(unsigned short *)point_addr = (unsigned short)color;	else if(32 == vbe_info.bits_per_pixel)		*(unsigned long *)point_addr = (unsigned long)color;		return TRUE;}/* * 画线。1像素。注意：坐标值从0开始 * I：线的起始点和结束点坐标，以及显示颜色 */BOOL draw_line(unsigned int Xstart, unsigned int Ystart, unsigned int Xend, unsigned int Yend, 				unsigned long color){	/* 防止越界 */	Xstart>=vbe_info.xresolution ? Xstart=vbe_info.xresolution-1 : 0;	Ystart>=vbe_info.yresolution ? Ystart=vbe_info.yresolution-1 : 0;	Xend>=vbe_info.xresolution ? Xend=vbe_info.xresolution-1 : 0;	Yend>=vbe_info.yresolution ? Yend=vbe_info.yresolution-1 : 0;	unsigned int tmp;	Xend<Xstart ? (tmp=Xend,Xend=Xstart,Xstart=tmp) : 0;	Yend<Ystart ? (tmp=Yend,Yend=Ystart,Ystart=tmp) : 0;	if(Yend-Ystart > Xend-Xstart) {		for(unsigned int y=Ystart; y<=Yend; y++)			draw_point((Xend-Xstart)/(Yend-Ystart)*(y-Ystart)+Xstart, y, color);	} else {		for(unsigned int x=Xstart; x<=Xend; x++)			draw_point(x, (Yend-Ystart)/(Xend-Xstart)*(x-Xstart)+Ystart, color);	}		return TRUE;}/* * 画矩形。边框1像素。注意：坐标值从0开始 * I：矩形左上角坐标、宽、高、颜色、是否填充 */BOOL draw_rect(unsigned int Xstart, unsigned int Ystart, unsigned int width, 			unsigned int height, unsigned long color, unsigned char isFill){	/* 宽或高不能为0 */	if(!width || !height)		return FALSE;	/*	 * 起始点宽（或高）+矩形宽（或高）=结束点。	 * 此处处理是为了画结束点，即与其他相同处理.	 */	width -= 1;	height -= 1;	/* 防止越界 */	Xstart>=vbe_info.xresolution ? Xstart=vbe_info.xresolution-1 : 0;	Ystart>=vbe_info.yresolution ? Ystart=vbe_info.yresolution-1 : 0;	Xstart+width>=vbe_info.xresolution ? width=vbe_info.xresolution-1-Xstart : 0;	Ystart+height>=vbe_info.yresolution ? height=vbe_info.yresolution-1-Ystart : 0;		/* 填充 */	if(isFill) {		for(unsigned int j=Ystart; j<=Ystart+height; j++)			for(unsigned int i=Xstart; i<=Xstart+width; i++)				draw_point(i, j, color);	} else {		draw_line(Xstart, Ystart, Xstart+width, Ystart, color);		draw_line(Xstart, Ystart, Xstart, Ystart+height, color);		draw_line(Xstart+width, Ystart, Xstart+width, Ystart+height, color);		draw_line(Xstart, Ystart+height, Xstart+width, Ystart+height, color);	}		return TRUE;}void graph_init(void){	vbe_info.xresolution 	= *(unsigned short *)(0x90000+20+18);	vbe_info.yresolution 	= *(unsigned short *)(0x90000+20+20);	vbe_info.bits_per_pixel = *(unsigned char *)(0x90000+20+25);	/* 获取保存的VESA显存的物理地址，并减去内核开始线性地址，得到内核模式下的虚拟地址 */	vbe_info.phys_base_ptr 	= *(unsigned long *)(0x90000+20+40)-0xC0000000;	d_delay(1000);	d_printf("vbe_info.phys_base_ptr = %d\n",vbe_info.phys_base_ptr);}